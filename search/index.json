[{"content":"理解“利率” 学习资料：(29) 关于利率，你需要知道的那些事儿 - YouTube\n‍\n概念理解 利率，俗称“利息”。可以理解为 “钱的时间成本”\n假设利率为 2%，那么今年的 100 块，相当于明年的 102 块。\n简单来说，你存入银行一笔钱，到期后，银行根据利率得给你一些利息，作为补偿。\n​​\n‍\n‍\n利率变化的重要性 降低利率 ——\u0026gt; 刺激经济？ 还是以 2% 的利率为例，假设所有条件不变，仅仅将利率降低到 0%。\n‍\n那么大伙就会认识到：钱放哪处，都是一样的，价值不会变。之前存在银行的时候，因为存在利率，所以当“存银行的受益”比“消费”更高的时候，大伙更倾向于存钱而不是消费\n降利率后，大家会认为钱存在哪里都是一样的，风险一致，所以更倾向于把“存在银行”的钱拿出来消费，置换为等价的商品：\n买房 买车 买包包 同时，利率为 0 时，借钱成本为 0，不需要支付利息。那么企业就会疯狂开始借钱发展，大力扩张。（不借白不借，没利息还怕啥）\n各行各业都会因为“消费者旺盛的消费”和“企业扩张”而高速发展，从业人员会更有钱。他们有钱之后，反而又会进一步再去消费其他领域的东西。这样就会形成一个良性循环。\n‍\n从这就可以看出：“降息”可以刺激经济发展。\n但凡事都存在代价 ‍\n降息后的代价 —— 通货膨胀 虽然降息后，可以大幅度刺激经济。但之后呢？\n刺激经济后，社会生产、消费旺盛，有钱人变多，那么企业就会涨价，以应对日益增长的消费需求和不匹配的生产能力，或者纯粹就是想“提高利润”。\n久而久之，这就会演变为“通货膨胀”，全社会的 CPI 上涨。\n‍\n所以，“加息”就有着“抑制通货膨胀”的作用，让高速发展的经济体降温。\n这就是为什么，美国面对控制不住的通货膨胀，美联储连续几次“加息”了。\n‍\n利率变化与通货膨胀的关系 ​​\n‍\n央行控制利率的方式 利率的组成 如果你要买房找银行借钱，银行凭什么要你 5% 的利率呢？\n这 5% 的利率的基本组成有 3 部分：\n无风险利率\n风险溢价\n银行评估我“还不上款”的机率。（评估我的财务状况） 银行利润\n银行借钱给我需要从中争取的“利润” 主要看“市场竞争” ​​\n‍\n‍\n“无风险利率”是根基，市面上看到的所有利率（房贷利率、信用卡利率、债券利率）都是基于此定价的。\n‍\n无风险利率 “无风险”意味着“一定能”拿到钱。现实生活中， “无风险”意味着“最高信用” ，在一国内拥有最高信用的只有“政府”。\n所以，一国政府所发行的“国债”的利率，可以近似认为是这个国家的货币的“无风险利率”。\n‍\n这些国债可以在“二级市场”上自由交易，那么我们可以通过这些价格倒推出“利率”的大小。以美国“十年期”国债价格为例：\n​​\n2.814% 就是美国 10 年起的“无风险利率” ‍\n‍\n每一个货币的“每一个时期”都对应着一个“无风险利率”：\n​​\n那么，以时间为横坐标，利率为纵坐标，就可以画出这个货币的“无风险利率曲线”：\n​​\n所以，一个经济体的核心利率不是一个固定数字，而是一个曲线。而这个曲线，就可以看作整个经济体的“根基”。\n‍\n通常情况下，曲线的形态是“向上”的，即“长期利率高于短期利率”\n但特殊情况的是，出现“曲线下降”的情况，说明“中长期利率低于短期利率”，这就叫做“利率倒挂”：\n​​\n‍\n央行控制的利率 前面我们推理的时候说“利率是由二级市场的交易价格来推到的”，则不是说明“利率由市场决定”的吗？\n但是，开头我们说过：无风险利率一般都是由央行控制的，那么央行到底控制“哪个利率”？\n‍\n从“无风险利率”曲线上看，央行一般控制的是“短期利率”，即曲线最左边的区域：\n​​\n控制的范围，不同央行不同规矩。一些央行会控制“一天的利率”，隔夜拆借利率 剩余的利率区域，都是受市场交易影响的，央行不能直接“调参数”。\n‍\n‍\n不过，央行可以自己印钱，自己下场去市场买“国债”，从而达到“调控利率”的结果：\n如果央行看 10 年期国债利率过高，那么它可能买多一点这个期限的国债 当央行把所有期限的国债利率都通过“买”的方式“压低利率”的时候，这个措施就叫做： “量化宽松” （QE）\n​​\n无限 QE 就是为了博取一点点通货膨胀 ‍\n总结关系 ​​\n央行可以去影响长期利率，但不能直接决定 ‍\n‍\n利率对经济的具体影响 利率与通胀 低利率 \u0026mdash;-\u0026gt; 引起通胀 高利率 \u0026mdash;-\u0026gt; 压低通胀 利率与债券 利率低，债券价格张 利率高，债券价格低 假设利率涨了，政府就得以更高的利息发债。相对来说，原来那些低息的债券看着就没那么诱人了。需求减少，自然价格会降低。\n‍\n不过不同期限的利率的“反比”关系就不这么明显。其实对于个人生活相关的期限应该是“中长期利率”—— 房贷、车贷等等的利息\n长期利率可以认为是“若干个短期利率的组合”，是我们对于未来的预期。\n​​\n长期利率可以参考政府预期的政策。就比如美联储为了抑制通胀，大伙都会预期美联储会不停加息，所以在市场上，中长期利率会涨：\n​​\n‍\n利率与股票 以下仅仅只是理论推导\n​​\n不同行业会有不同的影响，以房地产为例：加息会导致人们更倾向于“买房抵御风险”，这又会利好楼市股票：\n​​\n‍\n错综复杂的关系，不能一概而论 不能因为看了某些理论，而将其奉为“真理”。在市场中，所有要素都是相互关联的，都是动态的，任何一方的变化都会影响无数个与它关联的事物。\n‍\n利率是一个强大的宏观调控措施，它的变化影响着整体经济运行情况。\n但具体到每一个股票、每一个具体的公司，可能自身其他因素的影响远远大于利率的变化。\n利率很像月球对地球的引力，它的引力大小影响着地球的抄袭。\n但是具体到每一个个体做的每一个具体的事情来看，它的影响只是其一。\n以跳远为例，我们不会因为天上多了一个月亮，就能够跳的更高了。这其中影响最大的因素可能是自己的身体。\n‍\n加息对“利率行业”是利好的 加息通常来说，对银行业和保险业是利好的。利率越高，银行从“借贷差”之中挣取的钱更多。\n‍\n利率与房价 ​​\n不确定 受政策影响较大 ‍\n利率与黄金 ​​\n‍\n利率与汇率 利率可以理解为 “投资一个国家的回报率” 。以美元为例：\n美元利率变高，美元回报率升高 ‍\n但是，一国利率不只是一国自己的事情，它是相对的。我们对比两个国家的利率，得看 “相对利率” （利差）\n假设欧元与美元同时加息，但是欧元加息幅度比美元大 那么“欧元相对美元更有升值的压力” ‍\n","date":"2023-11-20T12:30:55.125+08:00","image":"https://hildam.github.io/p/%E7%90%86%E8%A7%A3%E5%88%A9%E7%8E%87/1700399303253_hu4bc9420973016362b182161ef699b4db_4197740_120x120_fill_box_smart1_3.png","permalink":"https://hildam.github.io/p/%E7%90%86%E8%A7%A3%E5%88%A9%E7%8E%87/","title":"理解“利率”"},{"content":"[Golang] 分布式定时任务模块研究 学习资料 xTimer 项目代码分析文章 golang 协程池文章 ‍\n术语表 术语 英文名 含义 分布式定时器服务 workflow.timer 前团队在工作实践中建设的定时器基础组件 定时器 timer 包含一组定时任务的定义的存储介质. 和定时任务是一对多关系，定时任务按照定时器的定义定时执行. 可以类比为一个闹钟 定时任务 timer task 定时器的一次执行实例，可以类比为闹钟提供的一次唤醒服务. 时间分片 time slice 基于一定长度将时间线切割为一系列分片，各定时任务基于执行时间从属于不同时间分片. 二维分片 time_bucket slice 在时间分片基础上，增加分桶维度，将每个时间范围内的定时任务尽可能均衡地划分到一系列二维分片中. 调取器模块 scheduler module 分布式定时器服务三大模块之一，负责在全局统筹分配定时任务集合. 调度器协程 scheduler goroutine 调度器模块中的并发执行单位，一个模块会根据配置开启多个协程并发工作. 触发器模块 trigger module 分布式定时器服务三大模块之一，负责主动轮询唤起达到执行条件的定时器. 触发器协程 trigger goroutine 触发器模块中的并发执行单位，一个模块会根据配置开启多个协程并发工作. 执行器模块 executor module 分布式定时器服务三大模块之一，负责执行定时任务. 执行器协程 executor goroutine 执行器模块中的并发执行单位，一个模块会根据配置开启多个协程并发工作. 迁移器模块 migrator module 负责将热点定时任务数据沿 关系型数据库-\u0026gt; 缓存组件 -\u0026gt; 节点内存 这一顺序进行迁移的模块.（目前还未实现） 一级时间步 time step1 迁移器批量将定时器任务从关系型数据库迁移到缓存组件的时间间隔. 二级时间步 time step2 迁移器批量将定时器任务从缓存组件迁移到节点内存的时间间隔. ‍\n‍\n定时任务实现思路 1. 主动轮询，扫表执行 抛开“分布式定时任务”这些高大上的名词，从最原始的需求出发，我们就是希望“任务”能够在“指定时间”执行。所以最简单的方法就是将任务执行的时间记录在一张表上，等到了指定时间后开始执行。\n‍\n于是乎，定时器需要 2 个核心模块：轮询器 + 触发器\n注册定时器：解析并将一系列定时任务平铺直叙地展开，每笔定时任务明确展示执行时间这一指标 节点自轮询：每间隔一个微小的时间范围，对定时任务列表进行全量查询 过滤\u0026amp;触发：以 执行时间小于等于当前时刻 作为过滤条件，摘出满足执行条件的定时任务进行执行. ​​\n‍\n这样就能满足“定时任务”的最基本需求。\n不过这个丐版的实现，每次执行需要耗费 O(N) 的时间复杂度，所以说它随着任务量的增加效率会逐渐降低。\n‍\n2. 存储优化 —— 有序表 上述的记录采用最基本的 MySQL 存储，这让每次查询的时间复杂度为 O(N)。查询的代价随着 N 记录数的增加而增加。\n我们可以通过将时间复杂度“平摊”到每一次查询中，比如说将存储结构更换为“红黑树”、“跳表”。\n将插入记录的时间复杂度由 O(1) -\u0026gt;O(logN)为代价，换取查询时间复杂度由O(N) -\u0026gt; O(logN) 的优化. ‍\n具体来说可以使用 Redis ZSet 进行存储，以定时任务执行时间为 Score 进行有序结构的搭建，当定时任务数量达到一定量级时，ZSet 底层基于跳表作为有序表的实现. 一些更细致的实现流程如下\n以 Redis ZSet 作为存储介质； 每次添加定时任务时，执行 ZAdd 动作，以执行时间的时间戳作为排序的键(Score) 进行有序结构的搭建； 每次查询定时任务时，执行 ZRangeByScore 动作，以当前时刻的时间戳加上一个微小偏移量作 score 的左右边界. ​​\n‍\n3. 存储优化 —— 纵向分治 上述的优化是在查询时间上面，而查询的范围是“整个”表格。\n但其实，我们只需要关注“即将执行”的任务，对于那些“更晚执行”的任务，其实是当前任务的干扰项，我们需要想办法“跳过”这些数据。\n‍\n我们可以对“时间”进行分片，先查询“接近即将执行”数据片段，这样就可以保证高效率。例如：\n插入每笔定时任务时，根据执行时间推算出所属的分钟级时间范围表达式，例如：2022-09-17-11:00:03 -\u0026gt; 2022-09-17-11:00:00_2022-09-17-11:01:00 以分钟级时间范围表达式为 key，将定时任务任务插入到不同 ZSet 中，组成一系列相互隔离的有序表结构. 每一次查询过程中，同样根据当前时刻推算出对应分钟级时间范围表达式，并以此为 key 查找到对应的有序表进行 ZRange 查询. ​​\n‍\n每一次执行的任务量从 N 下降到 N\u0026rsquo;（N\u0026rsquo; \u0026laquo; N)，大大提升每次执行的效率。\n‍\n‍\n4. 存储优化：横向分治 截止目前，我们都是站在“单核”的视角优化。对于生产环境下“分布式”的需求，我们还需要考虑如何在“集群”、“多核”层面优化。而且，golang 单个节点，也需要使用 goroutine 实现高并发。\n‍\n因为执行任务本身是一件 CPU 密集型任务，所以需要避免因为多协程介入导致出现“锁争抢”的问题。所以，在分片上需要做到资源的最小需求，每一个分片对应的任务集都应该只由一个 goroutine 负责轮询。\n因此相应的要求是，需要将时间分片拆解为更细的粒度，即在横向上额外增加一个分桶的维度，从而保证每个时间范围内能有对应于分桶数量的goroutine并发参加工作.\n‍\n流程优化：\n插入定时任务时，首先根据执行时间，确定其从属的时间范围； 其次，根据定时任务的唯一标识 id，结合服务对最大桶数的设置参数，随机将定时任务划分到一个桶中； 以时间范围和桶号组装形成一个新的 key，形成一个二维分片，实现对定时任务有序表的隔离； 后续步骤与 第三小节 一致 ​​\n‍\n‍\nxTimer 架构分析 作者开源项目地址：github.com/xiaoxuxianshe\u0026hellip;\n‍\n0. 自己看源码分析 画出了一个大致的草图，分析了 Scheduler、Trigger、Executer 三者的关联：\n​\n这三个模块是 xTimer 的核心，其余的组件（webserver、Logger、migrator）都是基于它们的关系进行处理的。\n‍\n三个模块通过 Ants 协程池相互关联，达到协调工作的效果。\n‍\n1. 架构设计 定时任务调度流程 根据上面的分析，定时任务模块至少包含“调度器”、“触发器”、“执行器”。\n而由于我们是单机任务，3 个模块都在同一个机器里面，所以我们可以利用 golang 的协程串联 3 个模块。使用“协程池”可以进一步优化协程的利用效率。\n​​\n3 个模块 + 2 个协程池 ‍\n‍\n‍\n优秀代码设计 以下对项目中某些代码片段进行着重分析，重点学习作者的设计思路\n1. 每个模块依次启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (w *Worker) Start(ctx context.Context) error { w.trigger.Start(ctx) ticker := time.NewTicker(time.Duration(w.appConfProvider.Get().TryLockGapMilliSeconds) * time.Millisecond) defer ticker.Stop() for range ticker.C { select { case \u0026lt;-ctx.Done(): log.WarnContext(ctx, \u0026#34;stopped\u0026#34;) return nil default: } w.handleSlices(ctx) } return nil } 这是在 Scheduler 模块的 Start 方法，它随后调用 Trigger 的 Start：\nw.trigger.Start(ctx) ‍\nTrigger 之后，也调用 Executor 的 Start 方法：\n1 2 3 func (w *Worker) Start(ctx context.Context) { w.executor.Start(ctx) } ‍\n然后 Executor 的 Start 方法调用 TimerService​ 的 Start 方法：\n1 2 3 func (w *Worker) Start(ctx context.Context) { w.timerService.Start(ctx) } ‍\n由上，我们再结合之前的架构图：\n​​\n‍\n便可梳理出整体的模块调用链：Scheduler -\u0026gt; Trigger -\u0026gt; Executor -\u0026gt; TimeService​\n这同时也进一步体现在每个 Struct 结构体的设计上：\nScheduler 包含着 Trigger\n1 2 3 4 5 6 7 8 type Worker struct { pool pool.WorkerPool appConfProvider appConfProvider trigger *trigger.Worker lockService lockService bucketGetter bucketGetter minuteBuckets map[string]int } Trigger 包含着 Executor\n1 2 3 4 5 6 7 type Worker struct { task taskService confProvider confProvider pool pool.WorkerPool executor *executor.Worker lockService *redis.Client } Executor 包含着 TimeService\n1 2 3 4 5 6 7 type Worker struct { timerService *TimerService taskDAO *taskdao.TaskDAO httpClient *xhttp.JSONClient bloomFilter *bloom.Filter reporter *promethus.Reporter } ‍\n‍\n2. Trigger 核心逻辑分析 —— 如何书写优秀的并发逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 func (w *Worker) Work(ctx context.Context, minuteBucketKey string, ack func()) error { // log.InfoContextf(ctx, \u0026#34;trigger_1 start: %v\u0026#34;, time.Now()) // defer func() { // log.InfoContextf(ctx, \u0026#34;trigger_1 end: %v\u0026#34;, time.Now()) // }() // 进行为时一分钟的 zrange 处理 startTime, err := getStartMinute(minuteBucketKey) if err != nil { return err } conf := w.confProvider.Get() ticker := time.NewTicker(time.Duration(conf.ZRangeGapSeconds) * time.Second) defer ticker.Stop() endTime := startTime.Add(time.Minute) notifier := concurrency.NewSafeChan(int(time.Minute/(time.Duration(conf.ZRangeGapSeconds)*time.Second)) + 1) defer notifier.Close() var wg sync.WaitGroup wg.Add(1) go func() { // log.InfoContextf(ctx, \u0026#34;trigger_2 start: %v\u0026#34;, time.Now()) // defer func() { // log.InfoContextf(ctx, \u0026#34;trigger_2 end: %v\u0026#34;, time.Now()) // }() defer wg.Done() if err := w.handleBatch(ctx, minuteBucketKey, startTime, startTime.Add(time.Duration(conf.ZRangeGapSeconds)*time.Second)); err != nil { notifier.Put(err) } }() for range ticker.C { select { case e := \u0026lt;-notifier.GetChan(): err, _ = e.(error) return err default: } if startTime = startTime.Add(time.Duration(conf.ZRangeGapSeconds) * time.Second); startTime.Equal(endTime) || startTime.After(endTime) { break } // log.InfoContextf(ctx, \u0026#34;start time: %v\u0026#34;, startTime) wg.Add(1) go func(startTime time.Time) { // log.InfoContextf(ctx, \u0026#34;trigger_2 start: %v\u0026#34;, time.Now()) // defer func() { // log.InfoContextf(ctx, \u0026#34;trigger_2 end: %v\u0026#34;, time.Now()) // }() defer wg.Done() if err := w.handleBatch(ctx, minuteBucketKey, startTime, startTime.Add(time.Duration(conf.ZRangeGapSeconds)*time.Second)); err != nil { notifier.Put(err) } }(startTime) } wg.Wait() select { case e := \u0026lt;-notifier.GetChan(): err, _ = e.(error) return err default: } ack() log.InfoContextf(ctx, \u0026#34;ack success, key: %s\u0026#34;, minuteBucketKey) return nil } ‍\n为什么在循环 for range ticker.C​ 还需要创建一个 go func()​ 协程。这个协程做的事情与 for range ticker.C​ 循环做的事情基本一致，这样的设计究竟是为了什么？ 为了确保调用函数后，go 协程的逻辑会立即得到执行。\n​for range ticker.C​ 循环中的逻辑，并不会在调用 trigger.Work 后会立即执行。\n‍\n循环 for range ticker.C​ 分析 每一个 for range 循环都创建一个 协程，执行批量处理的操作。每一次循环都有一个 select 监控管道，确保任何一个协程出现错误后，立即返回错误。\n同时，这个 select 会监听 2 个 channel 的信息：ticker 和 业务协程\nfor range ticker.C​ 循环确实会在每次迭代时阻塞，直到 ticker​ 通道接收到下一个时间点的信号。这是定时器 time.Ticker​ 的典型用法，用于在固定的时间间隔触发操作。具体来说：\n定时器的作用：\n​ticker := time.NewTicker(time.Duration(conf.ZRangeGapSeconds) * time.Second)​ 创建了一个定时器 ticker​，它会在设定的间隔（conf.ZRangeGapSeconds​ 秒）后向其通道 ticker.C​ 发送时间信号。 每次 ticker.C​ 接收到信号时，for range ticker.C​ 循环就会进行下一次迭代。 阻塞行为：\n在 for range ticker.C​ 循环中，每次迭代都会等待直到 ticker.C​ 通道接收到下一个时间点的信号。这意味着循环的每次迭代之间会有一个固定的时间间隔，这个间隔由 ticker​ 的设置决定。 在等待 ticker.C​ 通道的过程中，确实会发生阻塞。但这是有意为之的，以确保按照预定的时间间隔执行操作。 ​**select​ ** 语句的作用：\n在循环内部的 select​ 语句块用于检查是否有来自 notifier.GetChan()​ 的错误信号。这是一个非阻塞的检查，因为包含了 default​ 分支。 如果 notifier​ 通道中有错误，它会立即被处理并返回。如果没有错误，default​ 分支会执行，循环继续到下一次迭代。 ‍\n同时 ticket.C 只要不显式停止，它就会一直执行下去。在 for 函数内，只要执行时间达到 endTime 的时候，就会被停止，跳出循环！\n1 2 3 if startTime = startTime.Add(time.Duration(conf.ZRangeGapSeconds) * time.Second); startTime.Equal(endTime) || startTime.After(endTime) { break } 执行时间间隔为一分钟 ‍\nack() 前的 select 代码块的作用（gpt4） 代码最后的 select​ 语句块起着关键作用，特别是在处理并发操作和错误管理方面。具体来说：\n错误处理：\n这个 select​ 语句块用于检查 notifier.GetChan()​ 通道，以判断是否有来自并发执行的协程的错误。 如果某个协程在执行 w.handleBatch​ 函数时遇到错误并通过 notifier.Put(err)​ 发送了一个错误，那么这个错误会被放入 notifier​ 的通道中。 当 select​ 语句块执行时，它会从 notifier.GetChan()​ 通道中接收错误。如果通道中有错误，那么这个错误会被赋值给 err​ 变量，并由函数返回，从而传播错误。 确保所有协程完成：\n在这之前的 wg.Wait()​ 调用确保了在继续之前，所有由 Work​ 函数启动的协程都已经完成了它们的工作。 在所有协程完成之后，再次检查 notifier​ 通道是为了确保在协程执行过程中产生的任何错误都被捕获和处理。 非阻塞检查：\n使用 select​ 的 default​ 分支确保了这个错误检查是非阻塞的。如果 notifier​ 通道中没有错误，代码就会执行 default​ 分支，这避免了函数在此处无限期地等待。 干净的退出：\n如果所有协程都成功执行并且没有错误，那么这个 select​ 语句就不会捕获任何错误，函数将继续执行 ack()​ 调用和后续的日志记录，然后正常返回。 ‍\n‍\n3. golang 闭包函数在循环中的踩坑 —— 变量拷贝问题 在Go语言中，闭包（即函数内定义的匿名函数）会捕获其外部函数的变量。当这些闭包在并发环境（如多个协程）中执行时，就可能出现并发问题，尤其是当这些闭包共享对外部变量的访问时。\n在之前的代码示例中，有一段这样的代码：\n1 2 3 4 5 6 7 8 for _, task := range tasks { task := task // 重要的局部变量复制 if err := w.pool.Submit(func() { // ... 使用 task }); err != nil { return err } } 这里的关键点在于task := task​这行代码。它的作用及其重要性：\n闭包和外部变量：在for循环中，匿名函数（即闭包）是通过w.pool.Submit​提交并可能在不同的协程上执行的。这个闭包引用了循环变量task​。 变量捕获的工作原理：闭包不会为它引用的每次迭代创建**task**的独立副本。相反，所有迭代共享同一个**task**变量。这意味着闭包内部对**task**的引用在迭代时会改变。 并发问题的产生：如果没有局部变量复制，所有的闭包将引用相同的task​变量。由于这些闭包可能在不同的协程中并发执行，因此当task​在循环的下一次迭代中更新时，已经在执行中的闭包看到的task​值也会改变。这会导致所有闭包最终可能都使用最后一次迭代的**task**值，而不是它们各自迭代时的值。 局部变量复制的作用：通过task := task​，每次迭代都会创建task​的一个新副本。这样，每个闭包都捕获了这个副本而不是共享的循环变量。因此，即使外部循环继续进行并更新task​变量，每个闭包中捕获的副本值都不会改变。 不这么做的后果：如果不进行局部变量复制，所有并发执行的闭包可能都会错误地使用相同的（最后一次迭代的）task​值，导致数据不一致、错误的行为或其他难以追踪的并发相关的bug。 ‍\n简而言之，task := task​这种做法是确保闭包在并发执行时能安全使用迭代变量的一种重要且有效的技术。它避免了并发执行时由于变量共享导致的潜在问题，是Go语言并发编程中的一个常见且重要的模式。\n‍\n","date":"2023-11-20T10:30:55.125+08:00","image":"https://hildam.github.io/p/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9D%97%E7%A0%94%E7%A9%B6/113516139_p0_hu860343e6a89ea3c01b81e7ebe66315aa_2765491_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9D%97%E7%A0%94%E7%A9%B6/","title":"Golang 分布式定时任务模块研究"},{"content":"Fuction_Calling 快速入门 前言 Fuction Calling 的作用在于让 ChatGPT 返回的内容为“我们指定的 json 结构”，这样方便我们的项目函数直接处理 ChatGPT 的返回结构。\n在没有这个功能之前，只能通过 prompt 工程来约束 ChatGPT 的行为，但往往效果不佳，返回的 json 结构不能稳定使用。\n以下将以一个非常简单的需求来实现一个 Fuction Calling：输入一篇文章给 gpt，经它总结后，返回该文章的 标题、概述。\n‍\nFunction Calling 简单入门 核心步骤：\n定义 fuction，告诉 gpt 函数的“样貌”\n函数名字、函数功能描述、函数需要返回的参数 调用 gpt，同时指定需要调用的函数。\n‍\n1. 定于 Function 我们给 ChatGPT 的 Function 定义是一个 json 结构。它必须包含 3 个参数：\n​name​：指定这个 Function 的名字\n​description​：描述这个 Function 有什么功能\n​parameters​：这个函数返回什么参数，以及参数的类型是什么？\n​parameters​ 的结构也是以 json 进行描述，需要指定 type 为 \u0026ldquo;object\u0026rdquo;\n每个 parameters​ 变量都需要定义 type​、​description​\ntype：指定变量的类型 description：说明这个变量的用处 ‍\n以下是我们此次测试的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 functions = [ { \u0026#34;name\u0026#34;: \u0026#34;show_summary\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Shows the title and summary of some text.\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Title of the text output.\u0026#34; }, \u0026#34;summary\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Summary of the text output.\u0026#34; } } } } ] ‍\n2. 调用 ChatGPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 response = openai.ChatCompletion.create( # 指定model类型 model=\u0026#34;gpt-3.5-turbo-1106\u0026#34;, # prompt配置 messages = [ # 系统全局配置（可选） { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a useful assistant.\u0026#34; }, # 用户配置（必选，prompt的位置） { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: f\u0026#34;Here is an article: {article}. Please return a title ans summary that matches the text of it.\u0026#34; } ], # 可供chatgpt选择的function列表 functions = functions, # 指定这次调用的function类型 function_call = { \u0026#34;name\u0026#34;: \u0026#34;show_summary\u0026#34; } ) ‍\n根据调用的结果，我们先检查它的原始类型，再有针对性地使用 json 工具进行处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 print(response) # 输出 { \u0026#34;choices\u0026#34;: [ { \u0026#34;finish_reason\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;index\u0026#34;: 0, \u0026#34;message\u0026#34;: { \u0026#34;content\u0026#34;: null, \u0026#34;function_call\u0026#34;: { \u0026#34;arguments\u0026#34;: \u0026#34;{\\\u0026#34;title\\\u0026#34;:\\\u0026#34;The Mysterious Mansion\\\u0026#34;,\\\u0026#34;summary\\\u0026#34;:\\\u0026#34;The story revolves around a naive and clumsy girl named Xie Beileida, who becomes a maid at a grand mansion in the mountains. The mansion is managed by a talkative lady and a courteous viscount, and the maid enjoys a carefree life there. However, there is a forbidden rule that no one can approach the heavy wooden door leading to the underground basement. When the master of the mansion unexpectedly dies, the maid suspects that the secret of the mansion is related to his death and decides to open the forbidden door. What she discovers inside the door is a shocking revelation that unravels the mystery of the mansion and breaks an ancient curse. This tale of mystery and bravery leaves a deep impression on the protagonist, and she thanks the courageous girl, Xie Beileida, for giving the story a good ending.\\\u0026#34;}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;show_summary\u0026#34; }, \u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34; } } ], \u0026#34;created\u0026#34;: 1699774772, \u0026#34;id\u0026#34;: \u0026#34;chatcmpl-8JzM4BDXLVzeBay7aKNNXMwCTOfi9\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;gpt-3.5-turbo-1106\u0026#34;, \u0026#34;object\u0026#34;: \u0026#34;chat.completion\u0026#34;, \u0026#34;system_fingerprint\u0026#34;: \u0026#34;fp_eeff13170a\u0026#34;, \u0026#34;usage\u0026#34;: { \u0026#34;completion_tokens\u0026#34;: 177, \u0026#34;prompt_tokens\u0026#34;: 1220, \u0026#34;total_tokens\u0026#34;: 1397 } } ‍\njson 解析：\n1 2 3 4 5 6 7 # json 解析 arguments = response[\u0026#34;choices\u0026#34;][0][\u0026#34;message\u0026#34;][\u0026#34;function_call\u0026#34;][\u0026#34;arguments\u0026#34;] json_object = json.loads(arguments) print(json_object) # 输出 {\u0026#39;title\u0026#39;: \u0026#39;The Mysterious Mansion\u0026#39;, \u0026#39;summary\u0026#39;: \u0026#39;The story revolves around a naive and clumsy girl named Xie Beileida, who becomes a maid at a grand mansion in the mountains. The mansion is managed by a talkative lady and a courteous viscount, and the maid enjoys a carefree life there. However, there is a forbidden rule that no one can approach the heavy wooden door leading to the underground basement. When the master of the mansion unexpectedly dies, the maid suspects that the secret of the mansion is related to his death and decides to open the forbidden door. What she discovers inside the door is a shocking revelation that unravels the mystery of the mansion and breaks an ancient curse. This tale of mystery and bravery leaves a deep impression on the protagonist, and she thanks the courageous girl, Xie Beileida, for giving the story a good ending.\u0026#39;} ‍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 ## 3. 完整的可运行代码 ```python import os from dotenv import load_dotenv import openai import json from Function_Calling.utils import paragraph # 加载参数 load_dotenv() openai.api_key = os.getenv(\u0026#34;OPENAI_KEY\u0026#34;) # 使用chatgptAPI，归纳出总结文章的标题。返回结果要求是json结构 article = \u0026#34;\u0026#34; # 请自己输入文章 # 定义function结构。告诉chatgpt将要调用的functon是什么 functions = [ { \u0026#34;name\u0026#34;: \u0026#34;show_summary\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Shows the title and summary of some text.\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Title of the text output.\u0026#34; }, \u0026#34;summary\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Summary of the text output.\u0026#34; } } } } ] # OpenAI request response = openai.ChatCompletion.create( # 指定model类型 model=\u0026#34;gpt-3.5-turbo-1106\u0026#34;, # prompt配置 messages = [ # 系统全局配置（可选） { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a useful assistant.\u0026#34; }, # 用户配置（必选，prompt的位置） { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: f\u0026#34;Here is an article: {article}. Please return a title ans summary that matches the text of it.\u0026#34; } ], # 可供chatgpt选择的function列表 functions = functions, # 指定这次调用的function类型 function_call = { \u0026#34;name\u0026#34;: \u0026#34;show_summary\u0026#34; } ) # 打印全部 print(response) # json 解析 arguments = response[\u0026#34;choices\u0026#34;][0][\u0026#34;message\u0026#34;][\u0026#34;function_call\u0026#34;][\u0026#34;arguments\u0026#34;] json_object = json.loads(arguments) print(json_object) 请在该文件的同级下创建 .env 文件，里面配置好 OPENAI_KEY 的参数\n1 OPENAI_KEY=xxxxx ‍\n‍\n更精细的 Function 定义 How to call functions with chat models | OpenAI Cookbook\nFunction Calling 的核心难点在于如何定义一个“良好”的函数。在 OpenAI CookBook 中给出了一些比较好的定义参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 functions = [ { \u0026#34;name\u0026#34;: \u0026#34;get_current_weather\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Get the current weather\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The city and state, e.g. San Francisco, CA\u0026#34;, }, \u0026#34;format\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;celsius\u0026#34;, \u0026#34;fahrenheit\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The temperature unit to use. Infer this from the users location.\u0026#34;, }, }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;, \u0026#34;format\u0026#34;], }, }, { \u0026#34;name\u0026#34;: \u0026#34;get_n_day_weather_forecast\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Get an N-day weather forecast\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The city and state, e.g. San Francisco, CA\u0026#34;, }, \u0026#34;format\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;celsius\u0026#34;, \u0026#34;fahrenheit\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;The temperature unit to use. Infer this from the users location.\u0026#34;, }, \u0026#34;num_days\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The number of days to forecast\u0026#34;, } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;, \u0026#34;format\u0026#34;, \u0026#34;num_days\u0026#34;] }, }, ] ‍ # 让 Function 定义更灵活 我可以在 Function 中插入“变量”，让其随着程序的运行而变化。 比如接下来的例子中，将展示如何用 Function Calling 来动态生成指定的 SQL： ‍ 定义 Function： ```python functions = [ { \u0026#34;name\u0026#34;: \u0026#34;ask_database\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Use this function to answer user questions about music. Input should be a fully formed SQL query.\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;query\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: f\u0026#34;\u0026#34;\u0026#34; SQL query extracting info to answer the user\u0026#39;s question. SQL should be written using this database schema: {database_schema_string} The query should be returned in plain text, not in JSON. \u0026#34;\u0026#34;\u0026#34;, } }, \u0026#34;required\u0026#34;: [\u0026#34;query\u0026#34;], }, } ] ​{database_schema_string}​：我们传给 Function 的可变参数，用于指定某一个特定的表结构 ‍\n在配置询问的时候，我们就可以根据这个表结构，询问特定操作下的 SQL 如何写。以下是输出示例：\n1 2 3 4 5 user: What is the name of the album with the most tracks? assistant: {\u0026#39;name\u0026#39;: \u0026#39;ask_database\u0026#39;, \u0026#39;arguments\u0026#39;: \u0026#39;{\\n \u0026#34;query\u0026#34;: \u0026#34;SELECT al.Title, COUNT(t.TrackId) AS NumTracks FROM Album al INNER JOIN Track t ON al.AlbumId = t.AlbumId GROUP BY al.AlbumId ORDER BY NumTracks DESC LIMIT 1\u0026#34;\\n}\u0026#39;} function (ask_database): [(\u0026#39;Greatest Hits\u0026#39;, 57)] ","date":"2023-11-12T15:58:08.994+08:00","image":"https://hildam.github.io/p/fuction_calling-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1699747644613_huadb2298c974893890e316b9292267589_1494364_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/fuction_calling-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Fuction_Calling 快速入门"},{"content":"golang 依赖注入 依赖注入的需求 有些时候我们想要在使用 golang 的时候，无需关注对象创建的细节，希望随取随用。\n不过之前 Java 开发的时候，太过依赖于 Spring 了，以至于在 golang 的时候还是得靠框架实现，依赖注入自己不会手写。。。\n经阅读相关优先项目发现，大部分人都是用了 Uber 的 dig 开源框架，轻松在 golang 中实现“依赖注入”\n‍\ndig 的核心用法 Container dig 的 Container 即为“容器”，相当于 Spring 中“管理依赖的容器”。\n通过 New() 方法创建：\n1 container := dig.New() ‍\nProvide 我们需要告诉 dig 框架“对象的创建方法”，这样当我们需要某个对象的时候，它能够“调用这个对象的构造函数”。\nProvide 方法接收一个构造器函数作为参数，该函数负责具体数据类型的创建和初始化，并将其返回。如果待创建的数据类型依赖其他类型，可以将依赖作为构造函数参数来声明。\n所有依赖的构造器函数也必须注册进 Container ，但顺序没有严格要求\n‍\nProvide 的入参条件很灵活：\n1 2 3 4 5 // Provide accepts argument types or dig.In structs as dependencies, and // separate return values or dig.Out structs for results. func (c *Container) Provide(constructor interface{}, opts ...ProvideOption) error { return c.scope.Provide(constructor, opts...) } ‍\n不过“构造函数”必须返回一个对象的本身，否则不能创建成功：\n1 2 3 4 func provideApp(c *dig.Container) { ...... c.Provide(monitor.NewMonitorApp) } 1 2 3 4 5 6 7 8 func NewMonitorApp(worker *service.Worker) *MonitorApp { m := MonitorApp{ worker: worker, } m.ctx, m.stop = context.WithCancel(context.Background()) return \u0026amp;m } 向 Provide 提供 MonitorApp 的构造函数 ‍\n‍\n当然，构造函数也可以声明“任意个依赖”：\n1 2 3 4 5 6 err := c.Provide(func(u *UserGateway, c *CommentGateway) (*RequestHandler, error) { // ... }) if err != nil { // ... } 这段代码注册了 *RequestHandler 的构造函数，它有两个依赖，分别是 UserGateway 和 CommentGateway 。\n‍\n‍\n也可以返回“多个值”，完成多个类型的初始化：\n1 2 3 4 5 6 err := c.Provide(func(conn *sql.DB) (*UserGateway, *CommentGateway, error) { // ... }) if err != nil { // ... } 这段代码注册的构造函数，依赖数据库连接 *sql.DB ，负责 UserGateway 和 CommentGateway 的创建工作。\n‍\n‍\n构造函数可以接收可变参数，但 dig 执行时不会为其传参：\n1 func NewVoteGateway(db *sql.DB, options ...Option) *VoteGateway ‍\n‍\nInvoke Invoke 方法在我们需要使用“对象”的时候，向 Container 发起请求，获取对象。\n跟 Provide 一样，Invoke 方法也接收一个函数作为参数。函数通过参数指定要请求的数据类型，dig 负责创建这些类型，并执行该函数：\n1 2 3 4 5 6 err := c.Invoke(func(l *log.Logger) { // ... }) if err != nil { // ... } 这段代码调用 Invoke 方法请求日志对象 *log.Logger ， dig 先完成 *log.Logger 的创建工作，并将其传给该函数。 匿名函数里可以执行任何需要用到 *log.Logger 的处理逻辑，或者将其记下后再其他地方使用。 ‍\n在匿名函数中，我们可以将创建好的方法取出来：\n1 2 3 4 5 6 7 8 9 func GetMonitorApp() *monitor.MonitorApp { var monitorApp *monitor.MonitorApp if err := container.Invoke(func(_m *monitor.MonitorApp) { monitorApp = _m }); err != nil { panic(err) } return monitorApp } ‍\n多依赖、多输出的处理 如果构造一个对象，需要多个依赖；或者构造函数的返回值有多个对象的话，那么就会造成 Provide 入参和出参的臃肿，参数列表很长，可读性差。\n我们可以使用“结构体”来管理这些多对象的情况，这些结构体只要“组合”了 dig.In​ 和 dig.Out​，就能被 Provide 所识别。\n‍\n参数对象 任何结构体只要嵌入 dig.In 即视为参数对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 type HandlerParams struct { dig.In Users *UserGateway Comments *CommentGateway Posts *PostGateway Votes *VoteGateway AuthZ *AuthZGateway } func NewHandler(p HandlerParams) *Handler { // ... } 构造函数支持同时接受参数对象和普通参数，可以任意组合：\n1 2 3 func NewHandler(p HandlerParams, l *log.Logger) *Handler { // ... } ‍\n结果对象 1 2 3 4 5 6 7 8 9 10 11 type Gateways struct { dig.Out Users *UserGateway Comments *CommentGateway Posts *PostGateway } func SetupGateways(conn *sql.DB) (Gateways, error) { // ... } 这个构造器负责创建 *UserGateway 、*CommentGateway 和 *PostGateway ，可以使用结果对象改写成这样 ‍\n可选依赖 使用“结构体”管理后，可以很轻松解决“某些依赖”不存在的情况。\n如果说某些依赖不存在，可以构造一个“不完美”的对象，在没有使用“参数对象”的时候，需要构造多个函数来实现。\n‍\n在某些场景下，就算依赖缺失，组件也可降级工作。因此，组件构造函数不用强制依赖其他类型。dig 支持声明可选依赖，只要在参数对象相关字段上打上 optional:\u0026quot;true\u0026quot;​ 标签即可：\n1 2 3 4 5 6 type UserGatewayParams struct { dig.In Conn *sql.DB Cache *redis.Client `optional:\u0026#34;true\u0026#34;` } ‍\n如果可选依赖字段在容器中不存在，构造函数会收到该字段的零值：\n1 2 3 4 5 6 func NewUserGateway(p UserGatewayParams, log *log.Logger) (*UserGateway, error) { if p.Cache == nil { log.Print(\u0026#34;Logging disabled\u0026#34;) } // ... } ‍\n命名依赖 某些使用场景可能会为同个数据类型初始化多个实例，例如数据库连接可分为只读和读写：\n1 2 func NewReadOnlyConnection(...) (*sql.DB, error) func NewReadWriteConnection(...) (*sql.DB, error) dig 支持对实例值进行命名，将同个类型的多个不同实例加入容器。注册构造函数时可以传 dig.Name 参数，告诉 dig 对构造函数返回的实例值进行命名。如果构造函数返回多个值，每个值都会被命名。\n我们将上述两个数据库连接构造函数注册到 dig 容器，并通过可选参数 dig.Name 将它们分别命名为 ro 和 rw ：\n1 2 c.Provide(NewReadOnlyConnection, dig.Name(\u0026#34;ro\u0026#34;)) c.Provide(NewReadWriteConnection, dig.Name(\u0026#34;rw\u0026#34;)) ‍\n另一种方式，在结果对象中为字段打上命名标签：name:\u0026quot;xxxx\u0026quot;​ ，从而为实例值命名：\n1 2 3 4 5 6 7 8 9 10 11 type ConnectionResult struct { dig.Out ReadWrite *sql.DB `name:\u0026#34;rw\u0026#34;` ReadOnly *sql.DB `name:\u0026#34;ro\u0026#34;` } func ConnectToDatabase(...) (ConnectionResult, error) { // ... return ConnectionResult{ReadWrite: rw, ReadOnly: ro}, nil } ‍\n无论依赖用哪种方式命名，其他构建函数都可以通过参数对象准确获取。参数对象字段必须打上命名标签，指定要获取的依赖实例名，dig 据此注入同名且同类型的实例对象：\n1 2 3 4 5 6 type GatewayParams struct { dig.In WriteToConn *sql.DB `name:\u0026#34;rw\u0026#34;` ReadFromConn *sql.DB `name:\u0026#34;ro\u0026#34;` } ‍\n命名标签和可选依赖标签可以组合使用，声明可选的命名依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type GatewayParams struct { dig.In WriteToConn *sql.DB `name:\u0026#34;rw\u0026#34;` ReadFromConn *sql.DB `name:\u0026#34;ro\u0026#34; optional:\u0026#34;true\u0026#34;` } func NewCommentGateway(p GatewayParams, log *log.Logger) (*CommentGateway, error) { if p.ReadFromConn == nil { log.Print(\u0026#34;Warning: Using RW connection for reads\u0026#34;) p.ReadFromConn = p.WriteToConn } // ... } CommentGateway 的依赖由参数对象 GatewayParams 声明，它依赖两个数据库连接对象，一个是可读可写，另一个是只读的。注意到，只读连接是可选的，只读连接缺失则直接使用读写连接。 ‍\n‍\n实例组 为实现同一类型的多实例构建或消费，dig 引入了实例组（ value group ）的概念。实例组是容器内部的一个乱序命名集合，构造函数可以往该集合添加实例值，而其他构造函数可以请求集合中的所有实例，结果以 切片（ slice ）的形式返回。\n构造函数只要返回打上 group:\u0026quot;xxxx\u0026quot;​ 标签的 dig.Out 结果对象，相关字段就会被添加到实例组\n1 2 3 4 5 6 7 8 9 10 11 12 13 type HandlerResult struct { dig.Out Handler Handler `group:\u0026#34;server\u0026#34;` } func NewHelloHandler() HandlerResult { .. } func NewEchoHandler() HandlerResult { .. } 这段代码中两个构造函数注册后，dig 会将它们创建的 Handler 实例值添加到名为 server 的实例组。\n可能有任意多的构造函数往该命名组添加实例，而且其他构造函数借助同样打上 group:\u0026quot;xxxx\u0026quot;​ 标签的切片字段，即可请求全部实例值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type ServerParams struct { dig.In Handlers []Handler `group:\u0026#34;server\u0026#34;` } func NewServer(p ServerParams) *Server { server := newServer() for _, h := range p.Handlers { server.Register(h) } return server } Server 构造函数参数对象通过 Handler 字段请求 server 组中的所有 Handler 实例。dig 会先执行所有向该实例组添加实例值的构造函数，但执行顺序没有明确规定。 ‍\n实例组中的实例值是无序的，因为这些实例值的构建函数以什么顺序执行，dig 不作任何保证。\n‍\n在某些场景，我们可能需要在 dig.Out 中添加切片字段，以便同时向实例值添加多个值。然而，考虑到实例组必须通过切片来请求的原则，我们只能通过切片的切片来获取这些实例值。\n‍\n好在 v1.9.0 版本后，dig 支持将切片中的元素逐个加入实例值，而不是将切片本身。想要实现这种效果，只需要为 group 标签打上 flatten 修饰语即可：\n1 2 3 4 5 6 type IntResult struct { dig.Out Handler []int `group:\u0026#34;server\u0026#34;` // [][]int from dig.In Handler []int `group:\u0026#34;server,flatten\u0026#34;` // []int from dig.In } 第 4 行将切片本身添加进实例组，必须通过切片的切片（ [][]int​ ）来获取； 第 5 行将切片中的元素逐一加入实例组，通过实例切片（ []int​ ）获取即可； ‍\n","date":"2023-11-10T09:57:06.358+08:00","image":"https://hildam.github.io/p/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/F-GFw9_bQAAbpnT_hu8b370bc56ba849f07817004841874d66_136981_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","title":"golang 依赖注入"},{"content":"理解“通货膨胀”背后的逻辑 前言 基于 一口气了解通货膨胀 | 硬核 长篇视频的内容，对“通货膨胀”的前因后果，以及它如何作用于市场、作用于个人的情况，做笔记分析、思考\n‍\n通胀的定义以及衡量方式 定义 通货 —— 钱 膨胀 —— 贬值 所以通胀可以理解为“钱的贬值”。\n例如，上一年 3 元可以买小瓶的冰红茶，到今年就需要 3.5 了，钱没有增加，但是相应的购买力却下降了，钱的价值“被贬”了。\n‍\n衡量通胀的宏观指数 —— CPI 单一或某几个的消费品涨价，不能衡量整体通胀的情况。\n宏观指标中，CPI（消费者物价指数）是经济学中用以衡量整个经济体通胀的指标。它用于衡量经济体消费品的物价走势。\n‍\n​​\n以美国某个区间的 CPI 指数举例，CPI 指数的绝对值数值其实意义不大，我们更多的是看它与历史数据的倍数（增长）关系：\n以 296 CPI 为例，相当于是 CPI = 29 那一年的物价的 10 倍 这些年过去了，物价涨了 10 倍。60 年前的 1 美元，相当于这时候的 10 美元 ‍\n‍\n‍\n通胀与通缩 站在经济体的角度，理解金融现象 如果我们站在整个经济体的角度，钱无非就一个流通的工具，所以货币本身对应着购买力。对于一杯冰红茶“标价”是 3 块还是 300 块，它的标价意义不大。\n真正的意义在于，这个经济体通过什么样的方法，实现更高的产值，也就是 GDP。人们努力工作，获取财富；人们追求幸福，将手中的财富进行消费，并希望与更努力工作挣钱。这样，经济体运转更高效，更可持续地发展。\n‍\n明确了经济体的首要目标，我们再回头看“通胀”本身，才能理解通胀造成的经济现象的本质。\n通胀并不是好的，但也不是坏的，取决于通胀带来的影响是否能够让社会继续“发展”下去。\n‍\n通胀可以拉动经济增长 对于个人来说，我们更期望货币本身“越稳定越好”：今天它 100 块能买到的商品，1 年后甚至更久的时间里面，它还是能买到。\n稳定的财富锚点，易于持续的进行保值，巩固我们个人的财富。\n‍\n但站在经济体的角度思考，稳定的财富并不会让我们 GDP 快速地增长。\n因为财富的价值稳定，所以对于个人来说不会出现“狂热地消费”行为 个人的决策汇聚成集体的行为，整个社会的消费就会迟缓，呈现出“低活力”的状态。没有大量新增的消费需求，自然不会有大量新增的投资、生产 那如果你手中的钱在慢慢贬值呢？\n‍\n如果你手中的钱每个一年就会贬值一定比例，造成购买力的下降。今年能够买到的商品，明年就无法买到了。那么对于个人来说，他肯定会趋向于在财富尚未贬值之前，将其兑换。可以是消费，也可以是投资。\n这样，无形之中起到了刺激消费的作用，让人们心甘情愿地从银行中取钱出来消费。毕竟放在银行不用，钱对应的购买力仍然会下降。\n‍\n所以，“通货膨胀”无形之中起到了一个“财富再分配”的作用，而且是在无时无刻进行中的。\n它仿佛像一个不断追赶你的猛兽，逼迫你去挣钱、去消费、去生产，就是不能让你太安逸了。\n‍\n适量的通货膨胀，可以拉动经济增长。\n‍\n过高通胀的危害 —— 恶性通胀 通胀在合理区间，会驱使人们工作、努力挣钱。\n但过高的通胀，会直接挫伤人们的挣钱积极性，直接躺平\n如果今天我手中的钱可以买 100 瓶冰红茶，明天就只能买 50 瓶了，那么我们努力的价值又在何处呢？ 人们不会继续努力，因为今天努力的结果在明天一文不值。 ‍\n在恶心通胀下，社会生产力急剧下降。过高的商品价格抑制了消费需求，造成生产需求进一步下降。\n工厂会大面积倒闭，带来失业率的高涨。失业后人们更没钱了，更不会去消费。\n这就是恶性通胀带来的恶性循环，给经济体带来毁灭的打击。\n‍\n通货紧缩比通胀危害更大 通胀是“钱一年比一年少”，而通缩则是“钱一年比一年多”，但它带来的危机远比通胀更大。\n如果人们发现明年的钱比今年的钱买到的东西更多，那么人们更倾向于“存钱”\n啥都不做，就能实现财富增长，那为什么还要消费、工作、生产呢？ ‍\n但一旦每个人都想着“存钱、不消费”，那么整个社会的总需求就会下降。\n总需求下降导致生产需求下降，生产更少了。\n生产少了，工厂就会大面积开始倒闭。工厂倒闭就会裁员，于是乎失业率就会节节攀升。\n人们没工作了，钱更少了，也就会更保守、更不想花钱。\n于是乎，这个恶性循环就一直快速滚动下去，造成整个社会的经济崩溃。\n‍\n最核心的问题 ​​\n结合上述对通胀、通缩的讨论，其实最终要的问题不是物价的高与低，而是人们：\n不工作了 不花钱消费了 不生产了 都选择躺平了 **经济体最核心的元素是“人”，而人的选择出现了问题，直接影响到整个经济体的运行、发展。**通胀、通缩都是展现出来的表象。\n‍\n以日本为例，在日本 90 年代泡沫破裂后，人们进入低欲望社会。期间不管日本政府怎么刺激消费、企业怎么借债发展，人们依旧躺平，刺激没啥效果。\n直接结果就是，日本经济进入了“失去的 30 年”，停滞状态。\n‍\n我们关心通胀，不是关注价格的变化，而是“价格变化进而怎么影响到了需求的变化，进而会对 GDP 产生什么样的变化”\n‍\n合理的通胀，才能让经济持续发展 ​​\n‍\n大部分的经济体，一般都会把通胀率控制在 2 ~ 5% 的区间内。\n​​\n各国央行，不管用什么的政策，都是希望控制通胀率在合理区间。\n甚至说，央行的唯一目标就是控制通胀，让经济体合理稳健的运行。\n‍\n‍\n‍\n通胀发生的原因 有些人可能会猜是“央行印了太多的钱流进市场，让市场的货币太多了，从而造成货币贬值，引发通胀”。\n这结论，“对也不完全对”。\n有时候政府印钱，也不会通胀 有时候政府不印钱，它也会发生通胀 以日本过去为例，央行无限量地印钱，仍然还是通过紧缩的状态。。。\n‍\n不过总的来说，引发通胀的原因大致有以下 3 种：\n需求拉动型通胀 成本推动型通胀 过量货币供给造成的通胀 “预期”的通货膨胀会导致“实际”的通货膨胀 ‍\n1. 需求拉动型通胀 需求拉动型是一个良性的“通胀”模式。主要体现在“总需求”的增加，导致“产量”、“价格”的上涨，进而正向激励企业收入增加，并且满足消费需求的提高。\n而企业收入的增加，会让员工的收入增加。当收入增加，其他消费需求也会同时被激发，也会带动相关行业的需求提高，进而刺激这些行业的快速发展。\n这是一个良性循环， 拉动国家 GDP 的提高：\n​​\n‍\n总需求的提高，会带来经济的增长。通货膨胀是因为在产量满足不了需求的前期，商品价格会因市场的调节而提高。\n在此处，通货膨胀是“总需求提高”的一个结果，不是原因\n‍\n政府手段 正是因为“刺激需求的增长”可以拉动 GDP 的增长，所以政府很多情况下想要刺激经济，肯定想方设法刺激总需求。\n通货膨胀只是这一过程的一个副作用，一个现象，他不是政府行为的目的。\n​​\n‍\n刺激需求有很多种方法：\n政府自己掏钱，做好基建，减少阻碍消费的障碍；给企业补贴，让商品可以卖得便宜一点\n政府直接发钱给大伙，让大伙包里有钱去消费。\n比如川普在新冠的时候，直接给美国每人发美金，让他们去消费。\n其他西方国家因对新冠带来的消费需求低迷的情况，也做过类似的措施\n​​ ‍\n合适的刺激时机 促进经济发展的结果，会带来一定程度的通货膨胀，这几乎就是“买一送一”的\n不过如果选择刺激的时机不对，可能即时发钱出去了，也不会带来通货膨胀，更没有经济发展。而关键就是判断“产能是否充足”\n‍\n​​\n以“冰红茶店”为例子，假设冰红茶店有大量的冰红茶原材料没有使用，而且从业人员又不够，那么这个时间节点刺激冰红茶消费，会让这一部分产能充分释放出来：\n大量限制的冰红茶原材料被使用 冰红茶工厂招工需求旺盛，而且人才市场有充足的劳动力 这个时候刺激，会带来快速发展，带来十足的 GDP 增长，而通货膨胀也不会特别高。\n‍\n但是，如果是在冰红茶店产能已经达到瓶颈的情况下刺激（冰红茶店人满为患）。这个时候即使刺激力度非常大，也不会带来很高的增长（因为已经到临界点）。\n反而，由于货币超发，需求旺盛，进而拉高冰红茶的价格，导致非常高的通货膨胀，GDP 没有太大的增长。\n‍\n简单来说，产能充裕的时候是经济刺激的时机，这时候无论砸多少钱进去，看到的都是经济增长。反之产能已满的时候，砸钱只会引起“恶性通货膨胀”。\n‍\n从失业率看产能变化 失业率高，相关行业很多人没工作，所以“潜在的产能很大” 失业率低，相关行业已经接近饱和，所以“产能提升潜力小”，很难再增长 ‍\n结合历史数据来看，可以看到以下的规律：\n高通胀之前，会有一段时间“失业率很低”的情况\n​​\n负相关的关系 ‍\n失业率的高低，也可以反过来映衬“产能已满的情况刺激会带来通胀”的结论。\n如果社会失业率很低，说明基本上行业要继续投资发展，他无法再从市场上找到更多的劳动力。\n新兴企业有很大的动力去发展，苦于无法找到劳动力。面对日益激增的需求，和劳动力短缺，它只能选择“涨价”。也就带来了“通货膨胀”。\n‍\n‍\n2. 成本推动型通胀 企业因为商品的原材料价格上涨，或者支持生产基础工业品价格上涨（原油、粮食）。因为成本增高，企业利润率降低，为了保住利润率，企业只能涨价，将代价转嫁给消费者。\n‍\n单纯的商品价格上涨，会反过来抑制总需求。总需求的下降，会让产能下降，进而让企业降低对该商品的生产投入。\n​​\n这样的结果会导致“社会的产出下降”，进而导致 GDP 下降。\n‍\n‍\n3. 过量货币供给造成的通胀 适量的印钱可以带来通胀，进而让社会发展。但是无节制的印钱，肯定会导致恶性通胀，让整个社会货币疯狂贬值。\n纵观历史，很多时候恶性通胀的发生，都是因为政府无节制印钱导致的。但究竟是什么原因，导致政府无法控制自己印钱的步伐呢？它本可以让经济体通胀达到一个水平后停止印钱的？这其中肯定存在着一个“恶性循环”。\n‍\n政府不会傻到“自己印钱自己花”的地步，出现这个原因肯定是因为一些非常意外的因素，比如“战争”、“政治风波”。\n比如在德国一战战败后，它签署了一大堆赔款协议，欠下了一屁股债。但它本身也没钱呀，于是乎只能去自己印钱自己花。\n‍\n当政府无节制印钱的时候，在前期，社会总需求会快速增加。人们手里钱多了，自然会带来商品价格的增长。 —— 1. 需求拉动型通胀\n​​\n但是，由于人们的需求不是无限制的，大部分人仅仅只需要满足日常温饱即可，所以总需求增长会放缓。\n不过由于“政府的滞后性”，它还在不断地印钱，进而有一步推高了“商品价格”的提高。不过快速增长的价格，与产量的增加速度不匹配，毕竟工厂的建设花费的时机肯定比涨价要长。\n所以产量相对于价格的增长是“下降”的。因为“产能下降”了，导致“商品成本提高”，进而有刺激“商品涨价”。 —— 2. 成本推动型通胀\n这一个恶性循环一直会不断加强，货币不断加速贬值，最终社会生产崩溃。\n​​\n‍\n‍\n4. “预期”的通货膨胀会导致“实际”的通货膨胀 字面意思：就是大家认为“通胀”会发生的时候，即使政府没有计划通胀，那么“通胀”真的发生。\n墨菲定律 ‍\n​​\n大家预期价格会涨价，那么企业觉得“不涨白不涨”，干脆真的涨价了 那么企业收入增加，需求旺盛，反过来又再一次“印证”通货膨胀的发生 通货膨胀真的就发生了。。。 ‍\n这一个过程中，政府并没有印钱，也就是说社会的钱的总量没有变化，不过**“货币流通速度”**加快了。\n每个人都预期通货膨胀会发生，那么手里的钱明天可能比今天不值钱，都想着赶紧花钱。钱在每个人的停留时间就会变短。 花钱就会导致社会总需求的增加，更加会刺激价格的上涨。 市场上货币的流通量比之前多。 ‍\n所以，我们看央行在例行记者发布会上面介绍政策的时候，都是一脸的冷静，不会因为当前经济发生了什么很重大的事情而显得“惊慌失措”。\n其目的就是为了稳住市场的信心，让市场相信“问题很快就会解决”，调整预期。\n","date":"2023-11-04T15:29:37.188+08:00","image":"https://hildam.github.io/p/%E4%B8%80%E5%8F%A3%E6%B0%94%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/1687614900236_hud7c97c0fcdbb922afbdeb9da85c773b7_5527694_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/%E4%B8%80%E5%8F%A3%E6%B0%94%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/","title":"理解“通货膨胀”背后的逻辑"},{"content":"小德 MOMO 的视频 收到小德MOMO UP 主的启发，对财富的认知有了更深的理解：\n如何衡量财富？赶在失业前理解这个关键概念！ ‍\n“高消费”不是富裕的象征 很多人认为“高消费”、“奢侈品”就是衡量自己财富的价值标准。实际上，盲目追求这些外在的标准只会让自己的资金流衰竭。\n因为维持这些外在的符号，需要不断地投入金钱，不断消费。而自己一旦在财务方面存在问题，无力通过自身能力维持的话，只能通过“借贷”来继续高消费，消费未来的收益来支持当下的开销。\n“高消费”、“奢侈品”不是富裕的标准。越是信仰这些，离真正的财富就越远。\n‍\n以“时间”作为衡量财富多寡的标准 视频中以 A、B 两者作为对比，向我们展示了两种看待财富的人：\nA 是“符合社会”标准的“富裕”人士。他拥有大部分可以被社会大众看作“富裕”的象征 —— 高工资、汽车、房产、高消费 B 是所有城市中比较普通的打工人。工资不高、没房产、低消费。但他相比于 A 来说，存款特别多。 ‍\n乍一看，都会认为 A 比 B 富裕，很容易显而易见地认为 A 拥有的财富比 B 多。\n但实际上，A 的财富状况非常不稳定，只要 A 失业了，那么立即就会变得比 B 贫穷。\n‍\n以“时间”作为衡量标准，从“现金流”出发分析财富状况 在之前 UP 主的视频《小岛经济学》系列故事中，UP 主总结出了关于“财富”的新定义：\n$$ 财富不是以货币单位进行衡量的，而是以时间。一个人拥有多少财富，实际上指的是他能维持多少天生活。 $$\n在不同的时代和不同的国家，如果你不了解当地的背景，就很难明确理解一个国家的人，到底拥有多少财富才算得上富裕。\n举黄金为例，同一块黄金，在封建社会和现代社会中，能够支持一个人存活的时间是不同的。这个受到当时的文化、社会、战争等多方面影响。财富的高低不能客观地衡量在当时的财富状况。 但是只要知道他的财富足以让他维持多少天存活，就能够一目了然地知道他的富裕状况。 ‍\n我们用这个思路分析 A、B 两者的财务状况：假设人一个月的开销为 1000 块（恒定）\n在不失业的情况下：\nA 一个月净收入 800，加上存款 5000，可以存活 5.8 天 B 一个月净收入 2075，加上存款 40000，可以存活 42.075 天 在失业情况下：\nA 一个月总开销 14200，存款只有 5000，无任何除工资收入以外的来源，可能一天都活不下去。。。 B 存款 40000，可以存活很久。 可能有人会说 A 的其他资产很多，比如房子、汽车之类的。但是这些资产出售也需要时间成本，不能立即出手换钱的！\nA 失业后，只能通过贷款来偿还他身上的贷款。一旦走上贷款的路子，他之后的工作，都是为这些贷款而工作。\n以贷养贷，只会更进一步地恶化他的财务状况。\n‍\n在这个角度分析，就能够看到 A 仅仅只是看起来“富裕”，他的抗风险能力极其低，一旦他的现金流出了任何问题，都足以让他瞬间返贫。\n反观 B 的财务状况，虽然 B 的收入不高，但是他净收入比 A 高很多。而且他自己还有现金存款。整体抗风险能力强于 A 好几倍，即使在失业情况下也能够支撑很久，时间足够他找到下一份工作了。\n‍\n‍\n更准确的财富公式 $$ 财富水平=\\frac{资产}{\\left(每月的生活支出-每月资产被动收入\\right)} $$\n‍\n被动收入指的是“除去工资收入之外的其他收入来源” ‍\n小德MOMO 说，这样设计的原因是考虑到在当前社会环境不景气的情况下，失业和降薪都会成为常态。\n知道自己手中的钱能让维持自己多少天至关重要！ 这样自己就能够知道自己在失业后，需要在多少天之内找到工资。\n而且，在未来养老的时候，知道自己手中的钱可以维持老年后的自己多少天，也有助于在年轻的时候合理地进行理财，防范于未然。\n‍\n再一次重申：衡量财富的标准不是“消费水平”，而且时间！\n‍\n‍\n良性债务与不良债务 从以上的两个例子看出：A 由于借了太多的债务，导致他的抗风险能力非常弱。那我们是不是能够得出“不要借债”的结论呢？\n实际上，债务也可以分为“良性”与“不良”。良性债务可以让自己的财富得到翻倍提升，达到储蓄无法达到的高度。\n‍\n其实，富人的债务比我还要多，就那房地产老板来举例。23 年之前，总是可以看到某某某老板欠银行几个亿，但又都很快还上了。\n富人从银行里面借钱，用来发展业务，然后通过销售产品挣钱。他们每借的一笔钱，都有相应的人“替他们还债”。\n就好比，一个人从银行里面借了一大笔钱买一栋公寓，然后他将这栋公寓出租给很多租客，他再用这些租金偿还每个月的债务。 这样就变成了：他借银行的钱，租客为他还款。他可以通过提高租金来争取其中的差价。 ‍\n良性债务是“有人替你还贷”，不良债务是“你得为别人付出血汗”。\n如果你签了一份还款期为 30 年的不良贷款合同，那相当于签订了为期 30 年的不可中止劳动合同。 你支付的利息就是你给这些钱工作创造的收益，这些收益属于借钱给你的人，你得为别人付出血汗，而你得不到一分的报酬。 ‍\n‍\n总结感想 感觉上，只有一个人处于失业的状况下，才会冷静下来看一下自己生活的“支出项”，看看那些地方可以优化。\n和平、繁荣、进步的上升社会，并不多见。在 2023 年后，很可能长期处于一个缓缓回暖的状态。。。\n对于自己来说，仍是需要“量入为出”，谨慎地理财，不要陷入“消费主义”的陷阱中！\n","date":"2023-10-14T21:43:01.626+08:00","image":"https://hildam.github.io/p/%E4%BB%A5%E6%97%B6%E9%97%B4%E4%BD%9C%E4%B8%BA%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86%E4%BB%8E%E7%8E%B0%E9%87%91%E6%B5%81%E5%87%BA%E5%8F%91%E5%88%86%E6%9E%90%E8%B4%A2%E5%AF%8C%E7%8A%B6%E5%86%B5/FitAoCqVIAAzFgG_huc5da8a6b378ad920ce7c6f9c2f11ad4f_519935_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/%E4%BB%A5%E6%97%B6%E9%97%B4%E4%BD%9C%E4%B8%BA%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86%E4%BB%8E%E7%8E%B0%E9%87%91%E6%B5%81%E5%87%BA%E5%8F%91%E5%88%86%E6%9E%90%E8%B4%A2%E5%AF%8C%E7%8A%B6%E5%86%B5/","title":"以“时间”作为衡量标准，从“现金流”出发分析财富状况"},{"content":"一、问题描述 频繁的创建、销毁线程和线程池，会给系统带来额外的开销。未经池化及统一管理的线程，则会导致系统内线程数上限不可控。\n例如如下代码，每次发送邮件都会创建一个新的线程池，并且业务结束之后线程池也未随之销毁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static boolean sendMail(MailInfo mailInfo, MailServerInfo mailServerInfo) { try { ExecutorService executorService = Executors.newCachedThreadPool(); Future\u0026lt;Boolean\u0026gt; future = executorService.submit(() -\u0026gt; { try { return asyncSendEmail(mailInfo, mailServerInfo); } catch (Exception e) { return false; } }); return future.get(10, TimeUnit.SECONDS); } catch (Exception e) { LOG.error(e.getMessage(), e); return false; } } 这种情况下，随着访问数增加，系统内线程数持续增长，CPU负载逐步提高。极端情况下，甚至可能会导致CPU资源被吃满，整个服务不可用。\n为了解决上述问题，可增加统一线程池配置，替换掉自建线程和线程池。\n‍\n二、自建线程池 在 ThreadPoolConfig 中，创建统一线程池配置类，并交由 Spring 容器管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Configuration @EnableAsync public class ThreadPoolConfig implements AsyncConfigurer, SecureInvokeConfigurer { /** * 项目共用线程池 */ public static final String CHATTERHUB_EXECUTOR = \u0026#34;chatterHubExecutor\u0026#34;; /** * websocket通信线程池 */ public static final String WS_EXECUTOR = \u0026#34;websocketExecutor\u0026#34;; // GPT服务线程池 public static final String AICHAT_EXECUTOR = \u0026#34;aichatExecutor\u0026#34;; @Bean(CHATTERHUB_EXECUTOR) @Primary /** * @Primary是一个注解(Annotation),通常用于Java Spring框架中的Bean定义。它的作用是指定一个候选的Bean, * 当存在多个相同类型的Bean时，Spring容器会优先选择被@Primary注解标记的Bean作为注入的目标对象。 */ public ThreadPoolTaskExecutor chatterHubExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(10); executor.setMaxPoolSize(10); executor.setQueueCapacity(200); executor.setThreadNamePrefix(\u0026#34;chatterHub-executor-\u0026#34;); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); //满了调用线程执行，认为重要任务 executor.setThreadFactory(new MyThreadFactory(executor)); executor.initialize(); return executor; } ....... 这里面做了两件事，创建一个统一线程池，并且还通过实现AsyncConfigurer设置了@async注解也使用我们的统一线程池，这样方便统一管理。\n我们的线程池没有用Excutors快速创建。是因为Excutors创建的线程池用的无界队列，有oom的风险（小考点****）。\nexecutor.setThreadNamePrefix(\u0026ldquo;chattethub-executor-\u0026quot;)设置线程前缀，这样排查cpu占用，死锁问题或者其他bug的时候根据线程名，可以比较容易看出是业务问题还是底层框架问题。\n‍\n‍\n三、优雅停机 当项目关闭的时候，需要通过jvm的shutdownHook回调线程池，等队列里任务执行完再停机。保证任务不丢失。\nshutdownHook会回调spring容器，所以我们实现spring的DisposableBean的destroy方法也可以达到一样的效果，在里面调用executor.shutdown()并等待线程池执行完毕。\n由于我们用的就是spring管理的线程池\n​​\n连优雅停机的事，都可以直接交给spring自己来管理了，非常方便。\n内部源码，点进去可以看见。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public void destroy() { shutdown(); } /** * Perform a shutdown on the underlying ExecutorService. * @see java.util.concurrent.ExecutorService#shutdown() * @see java.util.concurrent.ExecutorService#shutdownNow() */ public void shutdown() { if (logger.isDebugEnabled()) { logger.debug(\u0026#34;Shutting down ExecutorService\u0026#34; + (this.beanName != null ? \u0026#34; \u0026#39;\u0026#34; + this.beanName + \u0026#34;\u0026#39;\u0026#34; : \u0026#34;\u0026#34;)); } if (this.executor != null) { if (this.waitForTasksToCompleteOnShutdown) { this.executor.shutdown(); } else { for (Runnable remainingTask : this.executor.shutdownNow()) { cancelRemainingTask(remainingTask); } } awaitTerminationIfNecessary(this.executor); } } ‍\n‍\n四、线程池使用 我们放进容器的线程池设置了beanName。\n​​\n‍\n业务需要用，也可以根据beanName取出想用的线程池。\n​​\n也可以直接在方法上面加异步注解 @Async\n​​\n‍\n五、异常捕获 搭建我们的项目的线程池，千万别忘了一点，就是线程运行抛异常了，要怎么处理。昨天一位哥们在群里问到这个问题，才发现很容易被人忽略，我们来看一看。\n1 2 3 4 5 6 7 public static void main(String[] args) { Thread thread =new Thread(()-\u0026gt;{ log.info(\u0026#34;111\u0026#34;); throw new RuntimeException(\u0026#34;运行时异常了\u0026#34;); }); thread.start(); } 看看这样一个语句，子线程执行报错，会打印错误日志吗？\n​​\n结果是这样的，异常并不会打印日志，只会在控制台输出。为啥呢？\n如果出了问题，却不打印error日志，那问题就被隐藏了，非常危险\n想要搞明白这个，首先要明白子线程的异常抛到哪里去了？\n异常的去处 传统模式下，我们一般会通过try catch的方法去捕获线程的异常，并且打印到日志中。\n1 2 3 4 5 6 7 8 9 Thread thread =new Thread(()-\u0026gt;{ try{ log.info(\u0026#34;111\u0026#34;); throw new RuntimeException(\u0026#34;运行时异常了\u0026#34;); }catch (Exception e){ log.error(\u0026#34;异常发生\u0026#34;,e); } }); thread.start(); ​​\n你会发现一个有意思的现象，当我们捕获了异常，就没有控制台的告警了，全都是日志打印。\n‍\n其实，如果一个异常未被捕获，从线程中抛了出来。JVM会回调一个方法​dispatchUncaughtException\n1 2 3 4 5 6 7 /** * Dispatch an uncaught exception to the handler. This method is * intended to be called only by the JVM. */ private void dispatchUncaughtException(Throwable e) { getUncaughtExceptionHandler().uncaughtException(this, e); } 这个方法在​Thread​类中，会进行默认的异常处理，其实就是获取一个默认的异常处理器。默认的异常处理器是\nThreadGroup实现的异常捕获方法。前面看到的​控制台ERR打印​，就出自这里。\n​​\n‍\n如何捕获线程异常 我们要做的很简单，就是给线程添加一个​异常捕获处理器​，以后抛了异常，就给它转成error日志。这样才能及时发现问题。\nThread有两个属性，一个类静态变量，一个实例对象。都可以设置异常捕获。区别在于一个生效的范围是单个thread对象，一个生效的范围是全局的thread。\n1 2 3 4 5 // null unless explicitly set private volatile UncaughtExceptionHandler uncaughtExceptionHandler; // null unless explicitly set private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler; 我们一般选择给每个thread实例都加一个异常捕获。毕竟别人的thread咱们别管，只管自己创建的thread。\n1 2 3 4 5 6 7 8 9 Thread thread = new Thread(() -\u0026gt; { log.info(\u0026#34;111\u0026#34;); throw new RuntimeException(\u0026#34;运行时异常了\u0026#34;); }); Thread.UncaughtExceptionHandler uncaughtExceptionHandler =(t,e)-\u0026gt;{ log.error(\u0026#34;Exception in thread \u0026#34;,e); }; thread.setUncaughtExceptionHandler(uncaughtExceptionHandler); thread.start(); ​​\n‍\n线程池的异常捕获 我们工作中一般不直接创建对象，都用的线程池。这下要怎么去给线程设置异常捕获呢？\n用线程池的​ThreadFactory​，创建线程的工厂，创建线程的时候给线程添加异常捕获。不了解的去补一补线程池基础哈\n1 2 3 4 5 private static ExecutorService executor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(500), new NamedThreadFactory(\u0026#34;refresh-ipDetail\u0026#34;,null, false, new MyUncaughtExceptionHandler())); 这是我的ip解析线程池，直接在工厂里添加一个异常捕获处理器就好了。它在创建thread的时候，会把这个异常捕获赋值给​thread​\n​​\n如果是这么简单，那一切到这儿就结束了。\n‍\nSpring 自身的线程池异常处理 我们还有两个线程池，用到了Spring的线程池。由于Spring的封装，想要给线程工厂设置一个捕获器，可是很困难的。\n1 2 3 4 5 6 7 8 9 10 11 @Bean(WS_EXECUTOR) public ThreadPoolTaskExecutor websocketExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(16); executor.setMaxPoolSize(16); executor.setQueueCapacity(1000);//支持同时推送1000人 executor.setThreadNamePrefix(\u0026#34;websocket-executor-\u0026#34;); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());//满了直接丢弃，默认为不重要消息推送 executor.initialize(); return executor; } ​​\n可以看到它自己实现了ThreadFactory。在​CustomizableThreadFactory​类的位置\n‍\n​​\n点进去可以看见它内部封装好的创建线程的方法\n​​\n压根就没有机会去设置一个线程捕获器。\n‍\n‍\n它的抽象类 ​​ExecutorConfigurationSupport ​​将自己赋值给线程工厂，提供了一个解耦的机会。\n​​\n如果我们把这个线程工厂换了，那么它的线程创建方法就会失效。线程名，优先级啥的全都得我们一并做了。而我们只是想扩展一个线程捕获。\n**这时候一个设计模式浮出脑海，**装饰模式（Wrapper、decorator）[^1]\n装饰器模式不会改变原有的功能，而是在功能前后做一个扩展点 。完全适合我们这次的改动。\n首先先写一个自己的线程工厂，把spring的线程工厂传进来。调用它的线程创建后，再扩展设置我们的异常捕获\n1 2 3 4 5 6 7 8 9 10 11 public class MyThreadFactory implements ThreadFactory { private ThreadFactory original; @Override public Thread newThread(Runnable r) { Thread thread = original.newThread(r); thread.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());//异常捕获 return thread; } } ‍\n第二步，替换spring线程池的线程工厂。\n​​\n一个完美的装饰器模式就这么写完了。\n有人问，这么复杂，为啥得要用spring的线程池，不用原生的呢？因为spring提供了很多优雅关闭等功能啊，看看 上面的文章。\n","date":"2023-10-14T16:43:01.626+08:00","image":"https://hildam.github.io/p/%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/FTwneuGaAAEIwOy_hu3cd8c2a946427a90a45d3467884b8180_568116_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"统一管理项目的线程池"},{"content":"Redis Lua 脚本实现大数据分批操作 Redis 大数据分批操作 一般来讲，如果 Redis 一次性执行太多数据的话，可能导致 Redis 服务主进程被长时间阻塞，造成其他命令的执行收到影响。\n可以使用 Lua 脚本对每次执行的数量做一个限制，数据量超过一定限制后，分批量执行\n‍\n代码实现 来源：DelayQueue —— golang 实现延迟队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local unack2retry = function(msgs) local retryCounts = redis.call(\u0026#39;HMGet\u0026#39;, KEYS[2], unpack(msgs)) -- get retry count for i,v in ipairs(retryCounts) do local k = msgs[i] if v ~= false and v ~= nil and v ~= \u0026#39;\u0026#39; and tonumber(v) \u0026gt; 0 then redis.call(\u0026#34;HIncrBy\u0026#34;, KEYS[2], k, -1) -- reduce retry count redis.call(\u0026#34;LPush\u0026#34;, KEYS[3], k) -- add to retry else redis.call(\u0026#34;HDel\u0026#34;, KEYS[2], k) -- del retry count redis.call(\u0026#34;SAdd\u0026#34;, KEYS[4], k) -- add to garbage end end end local msgs = redis.call(\u0026#39;ZRangeByScore\u0026#39;, KEYS[1], \u0026#39;0\u0026#39;, ARGV[1]) -- get retry msg if (#msgs == 0) then return end if #msgs \u0026lt; 4000 then unack2retry(msgs) else local buf = {} for _,v in ipairs(msgs) do table.insert(buf, v) if #buf == 4000 then unack2retry(buf) buf = {} end end if (#buf \u0026gt; 0) then unack2retry(buf) end end redis.call(\u0026#39;ZRemRangeByScore\u0026#39;, KEYS[1], \u0026#39;0\u0026#39;, ARGV[1]) -- remove msgs from unack 首先定义了一个名为unack2retry​的函数，该函数接收一个参数msgs​,表示未确认的消息列表。函数内部首先获取每个消息的重试次数，然后遍历这些消息，根据重试次数将它们分为三类：\n如果重试次数大于0,则将其添加到重试队列(使用LPush​命令); 否则，将其从重试次数哈希表中删除(使用HDel​命令),并将其添加到垃圾队列(使用SAdd​命令)。 接下来，从Redis中获取指定分数范围内的未确认消息(使用ZRangeByScore​命令)。如果没有未确认消息，则直接返回。\n如果未确认消息的数量小于4000,则直接调用unack2retry​函数处理所有未确认消息。否则，将未确认消息分批处理，每批最多包含4000条消息。对于每批消息，将其插入到一个缓冲区(buf​)中，当缓冲区满时，调用unack2retry​函数处理缓冲区中的未确认消息，并清空缓冲区。最后，如果缓冲区中仍有未确认消息，则调用unack2retry​函数处理剩余的消息。\n最后，从Redis中删除已处理过的未确认消息(使用ZRemRangeByScore​命令)。\n","date":"2023-10-14T10:35:07.811+08:00","image":"https://hildam.github.io/p/redis-lua-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%89%B9%E6%93%8D%E4%BD%9C/83565371_p0_hua456e595fa8251e7d0c86f0f4b777cf0_328426_120x120_fill_q75_box_smart1.jpg","permalink":"https://hildam.github.io/p/redis-lua-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%89%B9%E6%93%8D%E4%BD%9C/","title":"Redis Lua 脚本实现大数据分批操作"},{"content":"新时代人口发展趋势 前言 综合两位大佬的文章，可以推断出中国接下来的人口趋势走向。\n‍\n政事堂 2019 —— 新增人口结构变化 原文连接：mp.weixin.qq.com/s?__biz\u0026hellip;\n今天，国家卫健委正式发布了2022年的统计公报，2022年全国出生人口956万人，其中二孩占比为38.9%，三孩及以上占比为15.0%，出生人口性别比为111.1。\n数据的公布，正式官宣了中国自1962年以来首次实现了人口的负增长，中国将进入到漫长的人口下行通道。\n数据的比例不会说谎，我们对照前几年的数据，能够从人口看到中国未来的走势：\n2020年出生人口1200万人。二孩及以上孩次占比为57.1%（注：二胎占比约为50%，三胎及以上约为7%），出生人口性别比为110.46。\n2021年出生人口1062万人。二孩占比为41.4%，三孩及以上占比为14.5%，出生人口性别比为110.9。\n‍\n把过去三年的数据罗列起来，会发现很有趣。\n一胎，数据从515万-468万-441万，比例从42.9%-44.%-46.1%，出现了数据的下滑和比例的回升。\n二胎，数据从600万-440万-372万，比例从50%-41.4%-38.9%，出现了数据和比例的双重严重下滑。\n三胎以上，数据从85万-154万-143万，比例从7.1%-14.5%-15.0%，出现了数据的冲高收缩和比例的稳步上升。\n一胎的数据看起来很诡异，在新生人口大幅下滑的情况下，竟然出现了比例上的反弹。（这个暂时按下不表）\n二胎自2016年开放以来，作为中国生育主力，从近900万一路跌至370万，是中国出生数量大幅下滑的主因。\n尤其在新冠疫情带来的生理、心理与经济上的多重冲击下，二胎主力的中产阶级生育意愿大幅降低。\n三胎在2021年开放后，出现了生育意愿趋势显著高于二胎的情况，也成为了近年来人口新增方面的唯一亮点。\n经济形势乃至去年严重的疫情冲击，都没有影响那些想要生三胎的群体，对于他们来说，生孩子的主要制约来自于女性的身体，怎么也要隔一年再生一个。\n所以，我们再看去年的三胎（以上）占比15%，比例看似不多，但是乘以3孩或者乘以4孩，就会变成一个大比例，意味着接下来，中国一半的新增人口，实质上是由三孩、四孩家庭提供的。\n相较于持续下跌的二孩比例，我们再看反弹的一孩比例就会突然明白，一路生到三胎和四胎的群体，他们的动作自然会调整一二胎的比重。\n而且，这些新增的一胎年轻父母，其中有很多原本就是计划或者有能力生到三胎，经济形势，并不会影响他们的生育计划。\n毕竟，现在一胎的生育主力是95后和00后，他们的父辈普遍是70后，其中不少人在改革开放的浪潮中积累的大量的财富。\n也就是说，2020的疫情将是一个巨大的分水岭。\n‍\n‍\n2020年之前的生育结构，大概是一个两端尖中间胖的纺锤体，一孩家庭和俩孩家庭是绝对主力，不生以及大家庭的比重很少。\n2020年之后，一孩和俩孩家庭的比例将持续下行，不生以及大家庭的比重成为了绝对的主力。\n所以，虽然23年的人口还会持续下行，但数量真的不是问题所在，我们要考虑的是结构变化会产生什么样的影响。\n近期可以看房地产，大家庭的持续增加，会带动一二线的改善，推动资源的进一步集中。\n‍\n远期展望未来，20年后，当这些大家庭的3孩4孩开始步入社会，他们不仅拥有父辈的加持，哥哥姐姐的帮衬，以及两位数的堂哥和表姐夫。\n我大概就只能说到这里了，接下来，怎么做，怎么选，大家可以自行推理。\n‍\n‍\n求实处 —— 美国人口结构危机和全面内战 原文连接：mp.weixin.qq.com/s?__biz\u0026hellip;\n能不能生，能生几个，这不是问题。因为养得起几个，就生几个。喜欢几个，就生几个，这是自己的问题。\n人不能别人不想生孩子，强行让别人生孩子。孩子没有强行生出来的。出生的人少，就让别人硬生，这不行。\n人是宝贵的，因为人能劳动。人也是不好办的，因为人有自己的诉求。人不是机器人，不会听话的一直劳动，所以高素质的劳动力大军成了美国国会山老爷们最头疼的事情。\n美国的白人不太愿意生孩子了。\n‍\n白人的好处是，白人受教育程度高，服从程度高，但是一般白人家庭观念重。思想较为解放的白人家庭观念不重，但是不喜欢生孩子，因为有了孩子要付抚养费。\n黑人和拉美族裔就没有这个问题。黑人以社区居住，没有家庭观念，而且普遍没有钱，甚至买东西都没有钱，天天搞零元购，所以可以生孩子。毕竟，根本不用担心抚养费。\n只要我给不起，我就不用给。\n拉美人以大家族居住，几十口人一起住，喜欢生孩子。但是拉美人不怎么喜欢接受教育。主要靠生孩子做简单的劳动力来给大家族赚钱。毕竟，只要不给孩子上学，就能省下一大笔钱。\n只要孩子干的活足够简答，孩子数量足够大，就能给家里带来足够的收入。\n‍\n于是，新生儿中，白人的比例下降到了一半附近，换句话说，再过几十年，美国一半人口是拉美族裔或者是黑人，操一口西班牙语或者是黑人英语。\n另外一半的人口虽然是白人，但是白人本身也遇到了问题。如果白人的人口结构没啥问题，美国社会还是不会乱的。因为这个时候只有认同的矛盾，没有阶层的矛盾。\n美国的白人生育率，呈现出中国古代封建社会的趋势。有钱人家生好几个，没有钱的连结婚都费劲，遑论生孩子。\n富家家传家教家风好，孩子多，继承的资源多。但都是白人。\n底层家教家风不好，甚至可以说根本没有家风，但是孩子也多。继承的资源少，都不是白人。\n只有中间阶层，没有钱养孩子，越来越少。上层人口的孩子虽然多，但是只能淘汰一部分人补充到中间来。\n于是，美国的社会大概率出现上层人口多，资源多，下层人口人均资源极少，中间阶层逐渐消失的局面。\n‍\n立华我不由得想起了我国古代的一个历史时期。三国乱世结束后，战乱让中原人口大减。西北和北方的少数民族在曹魏和西晋政府的南迁政策下进入中原。\n从游牧到了农耕，生产力大幅增加，于是少数民族人口爆炸性增多。但是汉族的士族地主控制了全国大部分土地田庄。\n‍\n于是，尖锐的认同矛盾和分配矛盾爆发，最后以八王之乱为引子，搞起了五胡乱华。\n美国照着这个趋势下去，离全面内战也不远了。\n退一万步，如果美国真走到这一步，美国的霸权分崩离析，必然产生大量权力真空，但是权力没有真空，有空的地方，就有人要来填补。\n广阔天地， 大有可为。\n‍\n‍\n感想 两篇文章结合在一起看，抛开中美差距，都存在着上层资源集中，上层家庭大家族化的情况，尤其是中国放开生育限制的背景下。\n上层家庭的孩子越多，他们蚕食社会的优秀资源就越多；同时大家族之间会相互扶持，他们合作垄断社会资源的现象将愈发普遍。 中层家庭少生不生，他们的孩子向上层奋斗时，也会收到来自上层大家族势力更多的阻碍，进一步加速“阶级固化”。 下层家庭可以无视孩子的抚养成本狂生，毕竟他们也不想着孩子以后接收教育，只需要帮助他们干简单的活即可。而且他们能得到的社会资源相比中上层是最少的。 中层收到上层的不公平竞争，下层拥有匮乏的资源、贫苦的生活条件，将逐步撕裂整个社会。\n‍\n‍\n","date":"2023-10-13T22:28:37.285+08:00","image":"https://hildam.github.io/p/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%BA%BA%E5%8F%A3%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/640_hucdf3deb0b9b2c45991ee7d7a28529f44_166516_120x120_fill_box_smart1_3.png","permalink":"https://hildam.github.io/p/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%BA%BA%E5%8F%A3%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/","title":"新时代人口发展趋势"},{"content":"使用注解实现“接口事务” 前言 在之前处理接口的事务的时候，可能都是直接使用 TransactionManager 这一种“显式定义类”的方式，将接口传递给它，然后保证事务的实现。\n其实可以进一步将“事务调用”这一个方法抽离出来，让其成为一个“注解”，只要接口被“事务注解”所标记，那么它就会被事务处理\n使用示范 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 发送可靠消息，在事务提交后保证发送成功 * * @param topic * @param body */ @SecureInvoke public void sendSecureMsg(String topic, Object body, Object key) { Message\u0026lt;Object\u0026gt; build = MessageBuilder .withPayload(body) .setHeader(\u0026#34;KEYS\u0026#34;, key) .build(); rocketMQTemplate.send(topic, build); } 被 @SecureInvoke 注解后，执行 sendSecureMsg 方法会自动启用事务 ‍\n代码实现 自定义注解 @​​SecureInvoke​ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 保证方法成功执行。如果在事务内的方法，会将操作记录入库，保证执行。 */ @Retention(RetentionPolicy.RUNTIME)//运行时生效 @Target(ElementType.METHOD)//作用在方法上 public @interface SecureInvoke { /** * 默认3次 * * @return 最大重试次数(包括第一次正常执行) */ int maxRetryTimes() default 3; /** * 默认异步执行，先入库，后续异步执行，不影响主线程快速返回结果,毕竟失败了有重试，而且主线程的事务已经提交了，串行执行没啥意义。 * 同步执行适合mq消费场景等对耗时不关心，但是希望链路追踪不被异步影响的场景。 * * @return 是否异步执行 */ boolean async() default true; } ‍\n注解处理切片 ​SecureInvokeAspect​ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Slf4j @Aspect @Order(Ordered.HIGHEST_PRECEDENCE + 1)//确保最先执行 @Component public class SecureInvokeAspect { @Autowired private SecureInvokeService secureInvokeService; @Around(\u0026#34;@annotation(secureInvoke)\u0026#34;) public Object around(ProceedingJoinPoint joinPoint, SecureInvoke secureInvoke) throws Throwable { boolean async = secureInvoke.async(); boolean inTransaction = TransactionSynchronizationManager.isActualTransactionActive(); //非事务状态，直接执行，不做任何保证。 if (SecureInvokeHolder.isInvoking() || !inTransaction) { return joinPoint.proceed(); } Method method = ((MethodSignature) joinPoint.getSignature()).getMethod(); List\u0026lt;String\u0026gt; parameters = Stream.of(method.getParameterTypes()).map(Class::getName).collect(Collectors.toList()); SecureInvokeDTO dto = SecureInvokeDTO.builder() .args(JsonUtils.toStr(joinPoint.getArgs())) .className(method.getDeclaringClass().getName()) .methodName(method.getName()) .parameterTypes(JsonUtils.toStr(parameters)) .build(); SecureInvokeRecord record = SecureInvokeRecord.builder() .secureInvokeDTO(dto) .maxRetryTimes(secureInvoke.maxRetryTimes()) .nextRetryTime(DateUtil.offsetMinute(new Date(), (int) SecureInvokeService.RETRY_INTERVAL_MINUTES)) .build(); secureInvokeService.invoke(record, async); return null; } } 事务状态监控 用于记录每个线程的事务状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class SecureInvokeHolder { private static final ThreadLocal\u0026lt;Boolean\u0026gt; INVOKE_THREAD_LOCAL = new ThreadLocal\u0026lt;\u0026gt;(); public static boolean isInvoking() { return Objects.nonNull(INVOKE_THREAD_LOCAL.get()); } public static void setInvoking() { INVOKE_THREAD_LOCAL.set(Boolean.TRUE); } public static void invoked() { INVOKE_THREAD_LOCAL.remove(); } } ‍\n‍\n将切片配置 TransactionAutoConfiguration​ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @EnableScheduling @MapperScan(basePackageClasses = SecureInvokeRecordMapper.class) @Import({SecureInvokeAspect.class, SecureInvokeRecordDao.class}) public class TransactionAutoConfiguration { @Nullable protected Executor executor; /** * Collect any {@link AsyncConfigurer} beans through autowiring. */ @Autowired void setConfigurers(ObjectProvider\u0026lt;SecureInvokeConfigurer\u0026gt; configurers) { Supplier\u0026lt;SecureInvokeConfigurer\u0026gt; configurer = SingletonSupplier.of(() -\u0026gt; { List\u0026lt;SecureInvokeConfigurer\u0026gt; candidates = configurers.stream().collect(Collectors.toList()); if (CollectionUtils.isEmpty(candidates)) { return null; } if (candidates.size() \u0026gt; 1) { throw new IllegalStateException(\u0026#34;Only one SecureInvokeConfigurer may exist\u0026#34;); } return candidates.get(0); }); executor = Optional.ofNullable(configurer.get()).map(SecureInvokeConfigurer::getSecureInvokeExecutor).orElse(ForkJoinPool.commonPool()); } @Bean public SecureInvokeService getSecureInvokeService(SecureInvokeRecordDao dao) { return new SecureInvokeService(dao, executor); } @Bean public MQProducer getMQProducer() { return new MQProducer(); } } 使切片生效 ‍\n事务处理类 ​SecureInvokeService​ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @Slf4j @AllArgsConstructor public class SecureInvokeService { public static final double RETRY_INTERVAL_MINUTES = 2D; private final SecureInvokeRecordDao secureInvokeRecordDao; private final Executor executor; @Scheduled(cron = \u0026#34;*/5 * * * * ?\u0026#34;) public void retry() { List\u0026lt;SecureInvokeRecord\u0026gt; secureInvokeRecords = secureInvokeRecordDao.getWaitRetryRecords(); for (SecureInvokeRecord secureInvokeRecord : secureInvokeRecords) { doAsyncInvoke(secureInvokeRecord); } } public void save(SecureInvokeRecord record) { secureInvokeRecordDao.save(record); } private void retryRecord(SecureInvokeRecord record, String errorMsg) { Integer retryTimes = record.getRetryTimes() + 1; SecureInvokeRecord update = new SecureInvokeRecord(); update.setId(record.getId()); update.setFailReason(errorMsg); update.setNextRetryTime(getNextRetryTime(retryTimes)); if (retryTimes \u0026gt; record.getMaxRetryTimes()) { update.setStatus(SecureInvokeRecord.STATUS_FAIL); } else { update.setRetryTimes(retryTimes); } secureInvokeRecordDao.updateById(update); } private Date getNextRetryTime(Integer retryTimes) {//或者可以采用退避算法 double waitMinutes = Math.pow(RETRY_INTERVAL_MINUTES, retryTimes);//重试时间指数上升 2m 4m 8m 16m return DateUtil.offsetMinute(new Date(), (int) waitMinutes); } private void removeRecord(Long id) { secureInvokeRecordDao.removeById(id); } public void invoke(SecureInvokeRecord record, boolean async) { boolean inTransaction = TransactionSynchronizationManager.isActualTransactionActive(); //非事务状态，直接执行，不做任何保证。 if (!inTransaction) { return; } //保存执行数据 save(record); TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() { @SneakyThrows @Override public void afterCommit() { //事务后执行 if (async) { doAsyncInvoke(record); } else { doInvoke(record); } } }); } public void doAsyncInvoke(SecureInvokeRecord record) { executor.execute(() -\u0026gt; { System.out.println(Thread.currentThread().getName()); doInvoke(record); }); } public void doInvoke(SecureInvokeRecord record) { SecureInvokeDTO secureInvokeDTO = record.getSecureInvokeDTO(); try { SecureInvokeHolder.setInvoking(); Class\u0026lt;?\u0026gt; beanClass = Class.forName(secureInvokeDTO.getClassName()); Object bean = SpringUtil.getBean(beanClass); List\u0026lt;String\u0026gt; parameterStrings = JsonUtils.toList(secureInvokeDTO.getParameterTypes(), String.class); List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; parameterClasses = getParameters(parameterStrings); Method method = ReflectUtil.getMethod(beanClass, secureInvokeDTO.getMethodName(), parameterClasses.toArray(new Class[]{})); Object[] args = getArgs(secureInvokeDTO, parameterClasses); //执行方法 method.invoke(bean, args); //执行成功更新状态 removeRecord(record.getId()); } catch (Throwable e) { log.error(\u0026#34;SecureInvokeService invoke fail\u0026#34;, e); //执行失败，等待下次执行 retryRecord(record, e.getMessage()); } finally { SecureInvokeHolder.invoked(); } } @NotNull private Object[] getArgs(SecureInvokeDTO secureInvokeDTO, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; parameterClasses) { JsonNode jsonNode = JsonUtils.toJsonNode(secureInvokeDTO.getArgs()); Object[] args = new Object[jsonNode.size()]; for (int i = 0; i \u0026lt; jsonNode.size(); i++) { Class\u0026lt;?\u0026gt; aClass = parameterClasses.get(i); args[i] = JsonUtils.nodeToValue(jsonNode.get(i), aClass); } return args; } @NotNull private List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; getParameters(List\u0026lt;String\u0026gt; parameterStrings) { return parameterStrings.stream().map(name -\u0026gt; { try { return Class.forName(name); } catch (ClassNotFoundException e) { log.error(\u0026#34;SecureInvokeService class not fund\u0026#34;, e); } return null; }).collect(Collectors.toList()); } } ‍\n","date":"2023-10-12T15:45:56.251+08:00","image":"https://hildam.github.io/p/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C/112155320_p0_hu01d92a70b7b8c10e235bacf971634f06_5629370_120x120_fill_box_smart1_3.png","permalink":"https://hildam.github.io/p/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C/","title":"使用注解实现方法的事务执行"},{"content":"Github Page + Hugo 搭建免费开源博客 参考资料 搭建教程\n介绍 Hugo 与 Hexo 不同之处\nGtihub Actions 跨仓库发布 Pages\n官方 Actions 说明：github.com/marketplace/a\u0026hellip; 获取 Github PAT token：blog.csdn.net/m0_6396921\u0026hellip; 使用GitHub Actions跨仓库发布Package ‍\n个人博客书写流畅 思源草稿 本地博客写入 上传到 Github Page 仓库展示 搭建步骤 1. 从原作者的代码仓库中使用模板构建项目 github.com/CaiJimmy/hugo\u0026hellip; ​​\n我们根据这个模板来构建博客\n‍\n2. 构建两个仓库 我们配置 2 个仓库\n网站展示仓库（public） Hugo 源码仓库 展示仓库就是我们的 hildam.github.io，而源码仓库则是 private 的 hilda-blog\n自动化流程 我们在本地写好博客后，push 到 hilda-blog 仓库后，触发 Actions 操作，将 Hugo 构建好后的 public 文件夹，同步到 hildam.github.io 仓库中\n这样就可以一次 push，自动构建了！\n‍\n3. 配置好 Actions 文件 在原作者模板项目中，修改 deploy.yml 文件，着重在 Deploy 阶段增加目标仓库名字，和 Gtihub Token 信息即可：\n1 2 3 4 5 6 7 8 9 10 - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@v4 with: # 指定发布的仓库 repository-name: HildaM/hildam.github.io token: ${{ secrets.PAGE_TOKEN }} branch: main folder: public clean: true single-commit: true 详情需要参考：github.com/marketplace/a\u0026hellip;\n","date":"2023-10-12T00:00:00Z","image":"https://hildam.github.io/p/github-actions--hugo-%E6%90%AD%E5%BB%BA%E5%BC%80%E6%BA%90%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/assets/image-20231012120036-xdzsh1r_hu88c5ff595fb95e7279414238f4fa14ea_312798_120x120_fill_box_smart1_3.png","permalink":"https://hildam.github.io/p/github-actions--hugo-%E6%90%AD%E5%BB%BA%E5%BC%80%E6%BA%90%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","title":"Github Actions + Hugo 搭建开源博客系统"}]